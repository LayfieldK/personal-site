
<style>

text {
  font: 10px sans-serif;
}

</style>

<h1>D3 Bubble Chart (with Static Data)</h1>

<section id="graph"></section>

<script>

var diameter = 960,
    format = d3.format(",d"),
    color = d3.scale.category20c();

var bubble = d3.layout.pack()
    .sort(null)
    .size([diameter, diameter])
    .padding(1.5);

var svg = d3.select("body").append("svg")
    .attr("width", diameter)
    .attr("height", diameter)
    .attr("class", "bubble");

  d3.json("flare.json", function(error, root) {
  if (error) throw error;

  var node = svg.selectAll(".node")
      .data(bubble.nodes(classes(root))
      .filter(function(d) { return !d.children; }))
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

  node.append("title")
      .text(function(d) { return d.className + ": " + format(d.value); });

  node.append("circle")
      .attr("r", function(d) { return d.r; })
      .style("fill", function(d) { return color(d.packageName); });

  node.append("text")
      .attr("dy", ".3em")
      .style("text-anchor", "middle")
      .text(function(d) { return d.className.substring(0, d.r / 3); });
});

// Returns a flattened hierarchy containing all leaf nodes under the root.
function classes(root) {
  var classes = [];

  function recurse(name, node) {
    if (node.children) node.children.forEach(function(child) { recurse(node.name, child); });
    else classes.push({packageName: name, className: node.name, value: node.size});
  }

  recurse(null, root);
  return {children: classes};
}

d3.select(self.frameElement).style("height", diameter + "px");

</script>

<script>

var diameter = 960,
    format = d3.format(",d"),
    color = d3.scale.category20c();

var bubble = d3.layout.pack()
    .sort(null)
    .size([diameter, diameter])
    .padding(1.5);

var svg1 = d3.select("body").append("svg")
    .attr("width", diameter)
    .attr("height", diameter)
    .attr("class", "bubble1");

  d3.json("flare.json", function(error, root) {
  if (error) throw error;

  var node = svg1.selectAll(".node")
      .data(bubble.nodes(classes(root))
      .filter(function(d) { return !d.children; }))
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

  node.append("title")
      .text(function(d) { return d.className + ": " + format(d.value); });

  node.append("circle")
      .attr("r", function(d) { return d.r; })
      .style("fill", function(d) { return color(d.packageName); });

  node.append("text")
      .attr("dy", ".3em")
      .style("text-anchor", "middle")
      .text(function(d) { return d.className.substring(0, d.r / 3); });
});

// Returns a flattened hierarchy containing all leaf nodes under the root.
function classes(root) {
  var classes = [];

  function recurse(name, node) {
    if (node.children) node.children.forEach(function(child) { recurse(node.name, child); });
    else classes.push({packageName: name, className: node.name, value: node.size});
  }

  recurse(null, root);
  return {children: classes};
}

d3.select(self.frameElement).style("height", diameter + "px");

</script>

<script>
(function() {

  // Fake JSON data
  //var json = {"countries_msg_vol": {
  //  "CA": 170, "US": 393, "BB": 12, "CU": 9, "BR": 89, "MX": 192, "PY": 32, "UY": 9, "VE": 25, "BG": 42, "CZ": 12, "HU": 7, "RU": 184, "FI": 42, "GB": 162, "IT": 87, "ES": 65, "FR": 42, "DE": 102, "NL": 12, "CN": 92, "JP": 65, "KR": 87, "TW": 9, "IN": 98, "SG": 32, "ID": 4, "MY": 7, "VN": 8, "AU": 129, "NZ": 65, "GU": 11, "EG": 18, "LY": 4, "ZA": 76, "A1": 2, "Other": 254 
  //}};
  
  d3.json("starwarsplanets1.json", function(error, json) {
  
    // D3 Bubble Chart 

    var diameter = 1200;

    var svg2 = d3.select('#graph').append('svg')
                    .attr('width', diameter)
                    .attr('height', diameter);

    var bubble = d3.layout.pack().sort(null)
                .size([diameter, diameter])
                .value(function(d) {return d.size;})
         // .sort(function(a, b) {
                //  return -(a.value - b.value)
                // }) 
                .padding(3);
  
  // generate data with calculated layout values
  var nodes = bubble.nodes(processData(json))
                        .filter(function(d) { return !d.children; }); // filter out the outer bubble

 
  //var vis = svg2.selectAll('circle')
  //                  .data(nodes);
  
  //vis.enter().append('circle')
  //          .attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; })
  //          .attr('r', function(d) { return d.r; })
  //          .attr('class', function(d) { return d.className; });
  //          
   var node = svg2.selectAll("g")
      .data(nodes)
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

  node.append("title")
      .text(function(d) { return d.className + ": " + format(d.value); });

  node.append("circle")
      .attr("r", function(d) { return d.r; })
      .style("fill", function(d) { return color(d.packageName); });

  node.append("text")
      .attr("dy", ".3em")
      .style("text-anchor", "middle")
      .text(function(d) { return d.className.substring(0, d.r / 3); });
  
  function processData(data) {
    
    var obj = data;
//    alert(data.name)
    var planets = data.children;
//    alert(planets.length);
    var newDataSet = [];

//alert(planets[1].name);
    
    for(i=0; i < planets.length; i++){
      if(planets[i].population != "unknown"){
        newDataSet.push({name: planets[i].name, className: planets[i].name.toLowerCase(), size: Math.pow(planets[i].population, 1/3)});
      }
    }
    //for(var prop in planets) {
      
    //  newDataSet.push({name: planets[1].name, className: prop.toLowerCase(), size: obj[prop]});
      
    //}

    return {children: newDataSet};
  }
  
});
  
})();
</script>


<style>

	body {
		text-rendering: optimizeLegibility;
		margin: 0px;
	}

	svg {
		background-color: rgba(166, 178, 204, 1.000);
	}

	svg circle {
		fill: rgba(225, 152, 53, 1.000);
		-webkit-svg-shadow: -2px 1px 4px rgba(0, 0, 0, 0.6);
	}

	svg text {
		fill: rgba(255, 255, 255, 0.9);
		font-weight: normal;
		font-family: sans-serif;
		font-size: 10pt;
		text-anchor: middle;
		alignment-baseline: central;
	}

	svg .title {
		font-family: sans-serif;
		font-weight: bold;
		font-size: 32pt;
		letter-spacing: -0.05em;
		text-anchor: start;
		fill: rgba(255, 255, 255, 0.9);
	}

	svg div.labelDiv {
		padding: 0px;
		margin: 0px;
		display: table-cell;
		vertical-align: middle;
		text-align: center;
	}

	svg foreignObject {
		padding: 0px;
	}

	svg .label {
		font-weight: normal;
		font-family: sans-serif;
		font-size: 10pt;
		color: rgba(255, 255, 255, 0.9);
	}
	
	</style>
<script>
d3.json("starwarsplanets1.json", function(error, json) {
	var h = 500;
	var w = 1200;
	var minimumBubbleSize = 10;
	var labelsWithinBubbles = true;
	var title = "Relative Sizes Of The Planets, In Order Of Size";
	var dataset = [{label : "Mercury", value: 1134, xPos: 0},
	{label: "Venus ", value: 7088, xPos: 0},
	{label: "Earth", value: 7853, xPos: 0},
	{label: "Mars", value: 2206, xPos: 0},
	{label: "Jupiter", value: 983415, xPos: 0},
	{label: "Uranus", value: 125660, xPos: 0},
	{label: "Neptune", value: 113408, xPos: 0},
	{label: "Saturn", value: 693957, xPos: 0}];
	var gapBetweenBubbles = 15;
	var xPadding = 50;
	var yPadding = 100;
	var scaling = 20;


	/* Sort the dataset to ensure the bubble are always ascending */
	dataset = dataset.sort(function (a, b) { return (a.value - b.value);});
	
	/* Scale the dataset */
	var factor = minimumBubbleSize / dataset[0].value;
	dataset.forEach(function(d) { d.value = d.value * factor; });

	/* Scaling */

	function getRadius(area) {
		return Math.sqrt(area / Math.PI);
	}

	function getLabelDivSideFromArea(area) {
		return Math.sqrt(Math.pow(2 * rScale(area), 2) / 2);
	}

	var rScale = function(input) {
		/* Magic number here is just to get a reasonable sized smallest bubble */
		return getRadius(input) * scaling;
	}

	/* For bubbles that are too big to centre their text, compute a better position */

	function getNewXPosition(leftBubble, rightBubble) {

	}

	function getNewYPosition(leftBubble, rightBubble) {

	}

	/* Create the chart */

	var svg3 = d3.select("body")
	.append("svg")
	.attr("width", w)
	.attr("height", h)

	/* Adjust left hand side to add on the radius of the first bubble */
	xPaddingPlusRadius = xPadding + rScale(dataset[0].value);
	dataset[0].xPos = xPaddingPlusRadius;
	
	var bubble = d3.layout.pack().sort(null)
                .size([w, h])
                .value(function(d) {return d.size;})
         // .sort(function(a, b) {
                //  return -(a.value - b.value)
                // }) 
                .padding(3);
  
  // generate data with calculated layout values
  var nodes = bubble.nodes(processData(json))
                        .filter(function(d) { return !d.children; }); // filter out the outer bubble
	
	

	var node = svg3.selectAll("g")
	.data(nodes)
	.enter()
	.append("g")
	.attr("class", "node")
     .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

	node
	.append("circle")
	 .attr("r", function(d) { return d.r; })
      .style("fill", function(d) { return color(d.packageName); });;
	
	node.append("text")
	.attr("dy", ".3em")
      .style("text-anchor", "middle")
      .text(function(d) { return d.name; });
      
  

	var accumulator = xPaddingPlusRadius;
	
	

	/* Draw the chart title */

	svg3.append("text")
	.attr("x", xPadding)
	.attr("y", h - 40)
	.attr("class", "title")
	.text(title);
	
	function processData(data) {
    
    var obj = data;
//    alert(data.name)
    var planets = data.children;
//    alert(planets.length);
    var newDataSet = [];

//alert(planets[1].name);
    
    for(i=0; i < planets.length; i++){
      if(planets[i].population != "unknown"){
        newDataSet.push({name: planets[i].name, className: planets[i].name.toLowerCase(), size: Math.pow(planets[i].population, 1/3), value: Math.pow(planets[i].population, 1/3)});
      }
    }
    //for(var prop in planets) {
      
    //  newDataSet.push({name: planets[1].name, className: prop.toLowerCase(), size: obj[prop]});
      
    //}

    return {children: newDataSet};
  }
});
	</script>
